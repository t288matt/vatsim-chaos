<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ATC Conflict Animation - Dynamic Scheduling</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
    #cesiumContainer { position: absolute; top: 0; left: 0; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 12px; border-radius: 6px; z-index: 10; font-family: Arial, sans-serif; }
    #info h3 { margin: 0 0 8px 0; color: #00ff88; }
    #info p { margin: 4px 0; font-size: 12px; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #00ff88; padding: 20px; border-radius: 8px; z-index: 20; }
    .conflict-alert { background: rgba(255,0,0,0.3); border-left: 3px solid #ff4444; padding: 4px; margin: 2px 0; }
    #commentary-box { 
      position: absolute; 
      bottom: 10px; 
      right: 10px; 
      background: rgba(0,0,0,0.8); 
      color: #00ff88; 
      padding: 12px; 
      border-radius: 6px; 
      z-index: 10; 
      font-family: Arial, sans-serif; 
      max-width: 450px; 
      max-height: 500px; 
      height: 500px;
      overflow-y: auto;
      border-left: 3px solid #00ff88;
    }
    #conflict-commentary-box { 
      position: absolute; 
      bottom: 10px; 
      left: 10px; 
      background: rgba(0,0,0,0.8); 
      color: #00ff88; 
      padding: 12px; 
      border-radius: 6px; 
      z-index: 10; 
      font-family: Arial, sans-serif; 
      max-width: 450px; 
      max-height: 500px; 
      height: 500px;
      overflow-y: auto;
      border-left: 3px solid #00ff88;
    }
    #commentary-box h4 { margin: 0 0 8px 0; color: #00ff88; font-size: 14px; }
    .departure-log { 
      font-size: 11px; 
      margin: 2px 0; 
      padding: 2px 0; 
      border-bottom: 1px solid rgba(0,255,136,0.3);
    }
    .departure-time { color: #ffff00; font-weight: bold; }
    .flight-id { color: #00ffff; }
    .conflict-log { 
      font-size: 11px; 
      margin: 2px 0; 
      padding: 2px 0; 
      border-bottom: 1px solid rgba(0,255,136,0.3);
    }
    .conflict-time { color: #ffff00; font-weight: bold; }
    .conflict-flights { color: #00ffff; }
    .conflict-distance { color: #ffff00; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="loading">Loading ATC Conflict Animation...</div>
  <div id="info">
    <h3>üéØ ATC Conflict Animation</h3>
    <p><strong>Event:</strong> <span id="event-time">14:00-18:00</span></p>
    <p><strong>Flights:</strong> <span id="flight-count">0</span> active</p>
    <p><strong>Conflicts:</strong> <span id="conflict-count">0</span> detected</p>
    <p><strong>Current Time:</strong> <span id="current-time">14:00</span></p>
    <div id="conflict-alerts"></div>
    <button id="toggle-labels">Toggle Flight Labels</button>
  </div>
  <div id="controls" style="position:absolute;top:10px;right:10px;z-index:20;background:rgba(0,0,0,0.7);color:#fff;padding:10px;border-radius:6px;">
    <label>Aircraft Size: <input id="acft-size" type="range" min="64" max="1024" value="512" step="16"> <span id="acft-size-val">512</span></label><br>
    <label>Font Size: <input id="font-size" type="range" min="3" max="32" value="16" step="1"> <span id="font-size-val">16</span> px</label>
  </div>
  <div id="commentary-box">
    <h4>üì¢ Flight Commentary</h4>
    <div id="departure-logs"></div>
  </div>
  <div id="conflict-commentary-box">
    <h4>‚ö†Ô∏è Conflict Commentary</h4>
    <div id="conflict-logs"></div>
  </div>
  <script>
    // Auto-reload the page every 3 minutes (180,000 ms)
    setTimeout(function() {
      window.location.reload();
    }, 180000);
  </script>
  <script>
    // Best practice: Set up Cesium viewer and timeline for animation
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/';
    const viewer = new Cesium.Viewer('cesiumContainer', {
      timeline: true,
      animation: true,
      shouldAnimate: true,
      baseLayerPicker: false
    });
    viewer.clock.multiplier = 48;
    viewer.imageryLayers.removeAll();
    viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
      url: 'https://a.tile.openstreetmap.org/'
    }));
    const flightColors = [
      Cesium.Color.YELLOW, Cesium.Color.CYAN, Cesium.Color.LIME, Cesium.Color.ORANGE, 
      Cesium.Color.MAGENTA, Cesium.Color.RED, Cesium.Color.BLUE, Cesium.Color.GREEN,
      Cesium.Color.GOLD, Cesium.Color.AQUA, Cesium.Color.VIOLET, Cesium.Color.ROSE
    ];
    let flights = [];
    let conflicts = [];
    let flightEntities = [];
    let labelVisible = true;
    let selectedFlightId = null;
    let departedFlights = new Set(); // Track which flights have departed
    let lastUpdateTime = 0; // Track last update time to avoid duplicate logs
    let loggedConflicts = new Set(); // Track which conflicts have been logged
    document.getElementById('toggle-labels').onclick = () => {
      labelVisible = !labelVisible;
      flightEntities.forEach(e => {
        e.label.show = labelVisible;
      });
    };
    let acftSize = 512;
    let fontSize = 16;
    document.getElementById('acft-size').oninput = function() {
      acftSize = parseInt(this.value);
      document.getElementById('acft-size-val').textContent = acftSize;
      flightEntities.forEach(e => {
        if (e.model) {
          e.model.minimumPixelSize = acftSize;
          e.model.maximumScale = acftSize * 3;
        }
      });
    };
    document.getElementById('font-size').oninput = function() {
      fontSize = parseInt(this.value);
      document.getElementById('font-size-val').textContent = fontSize;
      flightEntities.forEach(e => {
        if (e.label) {
          e.label.font = fontSize + 'px sans-serif';
        }
      });
    };
    function parseUTCTimeToMinutes(utcTimeStr) {
      // Convert UTC "HHMM" string to minutes since event start (14:00)
      const hours = parseInt(utcTimeStr.substring(0, 2));
      const minutes = parseInt(utcTimeStr.substring(2, 4));
      const eventStart = 14 * 60;
      return (hours * 60 + minutes) - eventStart;
    }
    function minutesToTimeString(minutes) {
      const totalMinutes = 14 * 60 + minutes;
      const hours = Math.floor(totalMinutes / 60);
      const mins = totalMinutes % 60;
      return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }
    async function loadAnimationData() {
      try {
        // Read from interpolated data (single source of truth)
        const response = await fetch('/temp/routes_with_added_interpolated_points.json');
        if (!response.ok) throw new Error('Interpolated data not found: ' + response.status + ' ' + response.statusText);
        const text = await response.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch (jsonErr) {
          document.getElementById('info').innerHTML += '<br>‚ùå JSON parse error: ' + jsonErr.message;
          console.error('JSON parse error:', jsonErr);
          return false;
        }
        console.log('Loaded interpolated data:', data);
        
        // Convert interpolated data to frontend format
        flights = [];
        
        // Process each flight from interpolated data
        for (const [flightId, flightData] of Object.entries(data)) {
          if (flightId === '_metadata') continue; // Skip metadata
          
          if (flightData && typeof flightData === 'object' && flightData.route) {
            // Convert route waypoints to frontend format
            const waypoints = flightData.route.map((wp, index) => ({
              index: index,
              name: wp.name || '',
              lat: wp.lat,
              lon: wp.lon,
              altitude: wp.altitude,
              'UTC time': wp.time,
              stage: wp.stage || ''
            }));
            
            // Find departure and arrival from waypoints
            const departure = waypoints[0]?.name || '';
            let arrival = '';
            for (let i = waypoints.length - 1; i >= 0; i--) {
              if (waypoints[i].name && !waypoints[i].name.startsWith('CONFLICT_')) {
                arrival = waypoints[i].name;
                break;
              }
            }
            
            // Get departure time from metadata
            const departureTime = data._metadata?.departure_schedule?.[flightId]?.departure_time || '1400';
            
            // Create flight object
            const flight = {
              flight_id: flightId,
              departure: departure,
              arrival: arrival,
              departure_time: departureTime,
              aircraft_type: flightData.aircraft_type || 'UNK',
              waypoints: waypoints
            };
            
            flights.push(flight);
          }
        }
        
        // Load conflicts from dedicated conflict points file
        try {
          const conflictResponse = await fetch('conflict_points.json');
          if (conflictResponse.ok) {
            const conflictData = await conflictResponse.json();
            conflicts = conflictData;
            console.log('Loaded conflicts:', conflicts);
            

            console.log('Loaded conflicts from conflict_points.json:', conflicts.length);
          } else {
            console.warn('Conflict points file not found, using empty conflicts array');
            conflicts = [];
          }
        } catch (conflictError) {
          console.warn('Error loading conflict points:', conflictError);
          conflicts = [];
        }
        
        console.log('Processed flights:', flights);
        console.log('Processed unique conflicts:', conflicts);
        return true;
      } catch (error) {
        document.getElementById('info').innerHTML += '<br>‚ùå Data load error: ' + error.message;
        console.error('Data load error:', error);
        return false;
      }
    }
    function createScheduledFlights() {
      viewer.entities.removeAll();
      flightEntities = [];
      if (flights.length === 0) return;
      // Calculate global timeline
      let minTime = Infinity, maxTime = -Infinity;
      flights.forEach(flight => {
        if (flight.departure_time) {
          const departureMinutes = parseUTCTimeToMinutes(flight.departure_time);
          if (departureMinutes < minTime) minTime = departureMinutes;
        }
        flight.waypoints.forEach(wp => {
          if (wp['UTC time']) {
            const absoluteTime = parseUTCTimeToMinutes(wp['UTC time']);
            if (absoluteTime < minTime) minTime = absoluteTime;
            if (absoluteTime > maxTime) maxTime = absoluteTime;
          }
        });
      });
      const start = Cesium.JulianDate.fromDate(new Date(Date.now()));
      const stop = Cesium.JulianDate.addSeconds(start, (maxTime - minTime) * 60, new Cesium.JulianDate());
      // Set currentTime to the start of the first flight (minTime)
      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
      viewer.clock.multiplier = 1;
      viewer.clock.multiplier = 48;
      viewer.timeline.zoomTo(start, stop);
      viewer.clock.shouldAnimate = true;
      // Create flight entities with animated paths and 3D models
      flights.forEach((flight, idx) => {
        const color = flightColors[idx % flightColors.length];
        const property = new Cesium.SampledPositionProperty();
        const altitudeProperty = new Cesium.SampledProperty(Number);
        let entityStart = Infinity, entityStop = -Infinity;
        if (flight.departure_time) {
          const departureMinutes = parseUTCTimeToMinutes(flight.departure_time);
          if (departureMinutes < entityStart) entityStart = departureMinutes;
        }
        // Reverse waypoints so aircraft starts at origin and moves to destination
        const reversedWaypoints = flight.waypoints.slice().reverse();
        reversedWaypoints.forEach(wp => {
          if (wp['UTC time']) {
            const absoluteTime = parseUTCTimeToMinutes(wp['UTC time']);
            const t = Cesium.JulianDate.addSeconds(start, absoluteTime * 60, new Cesium.JulianDate());
            property.addSample(t, Cesium.Cartesian3.fromDegrees(wp.lon, wp.lat, wp.altitude));
            altitudeProperty.addSample(t, wp.altitude);
            if (absoluteTime < entityStart) entityStart = absoluteTime;
            if (absoluteTime > entityStop) entityStop = absoluteTime;
          }
        });
        const entityAvailability = new Cesium.TimeIntervalCollection([
          new Cesium.TimeInterval({
            start: Cesium.JulianDate.addSeconds(start, entityStart * 60, new Cesium.JulianDate()),
            stop: Cesium.JulianDate.addSeconds(start, entityStop * 60, new Cesium.JulianDate())
          })
        ]);
        const entity = viewer.entities.add({
          id: flight.flight_id,
          availability: entityAvailability,
          position: property,
          orientation: new Cesium.VelocityOrientationProperty(property),
          model: {
            uri: 'https://cesium.com/downloads/cesiumjs/releases/1.115/Apps/SampleData/models/CesiumAir/Cesium_Air.glb',
            minimumPixelSize: acftSize,
            maximumScale: acftSize * 3,
            color: Cesium.Color.BLACK.withAlpha(0.8),
            colorBlendMode: Cesium.ColorBlendMode.MIX
          },
          path: {
            resolution: 1,
            material: color,
            width: 2,
            leadTime: 0,
            trailTime: 60
          },
          label: {
            text: new Cesium.CallbackProperty(function(time, result) {
              const alt = altitudeProperty.getValue(time);
              const route = `${flight.departure}-${flight.arrival}`;
              const acftType = flight.aircraft_type || 'UNK';
              return `${flight.flight_id} (${acftType})\n${route}\nAlt: ${alt !== undefined ? Math.round(alt) : 'N/A'} ft`;
            }, false),
            font: fontSize + 'px sans-serif',
            fillColor: color,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            verticalOrigin: Cesium.VerticalOrigin.CENTER,
            pixelOffset: new Cesium.Cartesian2(60, 80), // Move label lower below the plane
            show: labelVisible
          }
        });
        flightEntities.push(entity);
      });

      // Remove camera auto-zoom logic so map does not move on first flight start
      // if (minLat < maxLat && minLon < maxLon && (maxLat - minLat > 0.01) && (maxLon - minLon > 0.01)) {
      //   viewer.zoomTo(viewer.entities);
      // } else {
      //   const ausRect = Cesium.Rectangle.fromDegrees(110, -45, 155, -10);
      //   viewer.camera.flyTo({ destination: ausRect, duration: 1.5 });
      // }
    }
    function createConflictMarkers(conflictPoints) {
      conflictPoints.forEach((conflict, index) => {
        const position = Cesium.Cartesian3.fromDegrees(conflict.lon, conflict.lat, conflict.altitude);
        viewer.entities.add({
          id: `conflict_marker_${index}`,
          position: position,
          point: {
            pixelSize: 15,
            color: Cesium.Color.RED,
            outlineColor: Cesium.Color.WHITE,
            outlineWidth: 3,
            heightReference: Cesium.HeightReference.NONE
          }
        });
      });
    }
    function updateUI() {
      document.getElementById('flight-count').textContent = flights.length;
      document.getElementById('conflict-count').textContent = conflicts.length;
      const currentTime = viewer.clock.currentTime;
      const seconds = Cesium.JulianDate.secondsDifference(currentTime, viewer.clock.startTime);
      const minutes = Math.floor(seconds / 60);
      const timeStr = minutesToTimeString(minutes);
      document.getElementById('current-time').textContent = timeStr;
      
      // Check for new departures
      checkForDepartures(minutes, timeStr);
      
      const activeConflicts = conflicts.filter(conflict => {
        if (!conflict.conflict_time) return false;
        const conflictTime = parseUTCTimeToMinutes(conflict.conflict_time);
        // Show conflict only if current time matches exactly the conflict time
        return minutes === conflictTime;
      });
      
      // Log new conflicts to commentary
      activeConflicts.forEach(conflict => {
        const conflictKey = `${conflict.flight1}_${conflict.flight2}_${conflict.conflict_time}`;
        if (!loggedConflicts.has(conflictKey)) {
          loggedConflicts.add(conflictKey);
          
          // Add conflict to commentary
          const conflictLogsContainer = document.getElementById('conflict-logs');
          const conflictTime = minutesToTimeString(minutes);
          const conflictLog = document.createElement('div');
          conflictLog.className = 'conflict-log';
          conflictLog.innerHTML = `
            <span class="conflict-time">${conflictTime}</span> - 
            <span class="conflict-flights">${conflict.flight1} vs ${conflict.flight2}</span><br>
            <span class="conflict-distance">Distance: ${conflict.distance.toFixed(1)}nm, Alt: ${conflict.altitude}ft</span>
          `;
          conflictLogsContainer.appendChild(conflictLog);
          
          // Auto-scroll to bottom
          conflictLogsContainer.scrollTop = conflictLogsContainer.scrollHeight;
        }
      });
      const alertsDiv = document.getElementById('conflict-alerts');
      alertsDiv.innerHTML = '';
      activeConflicts.forEach(conflict => {
        const alertDiv = document.createElement('div');
        alertDiv.className = 'conflict-alert';
        // Use Alt: and Sep: fields instead of lat/long
        const alt = conflict.altitude !== undefined ? Math.round(conflict.altitude) + 'ft' : 'N/A';
        const dist = conflict.distance !== undefined ? conflict.distance + 'nm' : 'N/A';
        // Convert flight IDs to both flight ID and route for display
        const getFlightInfoFromFlightId = (flightId) => {
          const flight = flights.find(f => f.flight_id === flightId);
          if (flight) {
            const route = `${flight.departure}-${flight.arrival}`;
            const acftType = flight.aircraft_type || 'UNK';
            return `${flightId} (${acftType}) (${route})`;
          }
          return flightId;
        };
        const flight1Info = getFlightInfoFromFlightId(conflict.flight1);
        const flight2Info = getFlightInfoFromFlightId(conflict.flight2);
        alertDiv.innerHTML = `‚ö†Ô∏è ${flight1Info} vs ${flight2Info}  Alt: ${alt}  Dist: ${dist}`;
        alertsDiv.appendChild(alertDiv);
      });
      // Set all aircraft to black by default
      flightEntities.forEach(entity => {
        if (entity.model) {
          entity.model.color = Cesium.Color.BLACK.withAlpha(0.8);
        }
      });
      // Set aircraft involved in active conflicts to red
      activeConflicts.forEach(conflict => {
        [conflict.flight1, conflict.flight2].forEach(flightId => {
          const entity = flightEntities.find(e => e.id === flightId);
          if (entity && entity.model) {
            entity.model.color = Cesium.Color.RED.withAlpha(0.8);
          }
        });
      });
    }
    
    function checkForDepartures(currentMinutes, timeStr) {
      flights.forEach(flight => {
        if (flight.departure_time) {
          const departureMinutes = parseUTCTimeToMinutes(flight.departure_time);
          if (currentMinutes >= departureMinutes && !departedFlights.has(flight.flight_id)) {
            departedFlights.add(flight.flight_id);
            logDeparture(flight.flight_id, timeStr, flight.departure_time);
          }
        }
      });
    }
    
    function logDeparture(flightId, currentTime, scheduledTime) {
      const logsDiv = document.getElementById('departure-logs');
      const logEntry = document.createElement('div');
      logEntry.className = 'departure-log';
      // Convert flight ID to both flight ID and route for display
      const flight = flights.find(f => f.flight_id === flightId);
      if (flight) {
        const route = `${flight.departure}-${flight.arrival}`;
        const acftType = flight.aircraft_type || 'UNK';
        logEntry.innerHTML = `<span class="departure-time">${currentTime}</span> - <span class="flight-id">${flightId} (${acftType}) (${route})</span> departed`;
      } else {
        logEntry.innerHTML = `<span class="departure-time">${currentTime}</span> - <span class="flight-id">${flightId}</span> departed`;
      }
      
      // Check if we're at the bottom before adding new entry
      const wasAtBottom = logsDiv.scrollTop + logsDiv.clientHeight >= logsDiv.scrollHeight - 1;
      
      logsDiv.appendChild(logEntry);
      
      // Don't remove any entries - let the scroll handle overflow naturally
      // The commentary box will scroll when it gets full
      
      // Auto-scroll to bottom only if we were already at the bottom
      if (wasAtBottom) {
        logsDiv.scrollTop = logsDiv.scrollHeight;
      }
    }
    // Highlight selected flight
    viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
      const pickedObject = viewer.scene.pick(movement.position);
      if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.id) {
        const flightId = pickedObject.id.id;
        selectedFlightId = flightId;
        flightEntities.forEach(e => {
          if (e.id === flightId) {
            e.path.material = Cesium.Color.WHITE;
            e.path.width = 6;
          } else {
            e.path.material = flightColors.find(c => c.equals(e.path.material)) || Cesium.Color.YELLOW;
            e.path.width = 2;
          }
        });
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    async function initializeVisualization() {
      document.getElementById('loading').style.display = 'block';
      try {
        const animationLoaded = await loadAnimationData();
        if (animationLoaded) {
          createScheduledFlights();
          createConflictMarkers(conflicts); // Call the new function here
        } else {
          flights = [
            {
              flight_id: 'Demo Flight 1',
              departure_time: '1400',
              waypoints: [
                { lon: 151.177, lat: -33.946, altitude: 0, utc_time: '1400' },
                { lon: 153.117, lat: -27.384, altitude: 10000, utc_time: '1410' },
                { lon: 144.843, lat: -37.673, altitude: 0, utc_time: '1420' }
              ]
            }
          ];
          createScheduledFlights();
          createConflictMarkers(conflicts); // Call the new function here
        }
        // Set camera to fixed rectangle (Southeastern Australia - broader coverage)
        const startRect = Cesium.Rectangle.fromDegrees(135.0, -39.0, 154.0, -29.0);
        viewer.camera.setView({ destination: startRect });
        // Remove viewer.zoomTo(viewer.entities) and other auto-zoom logic
        // Remove viewer.camera.flyTo({ destination: ausRect, duration: 1.5 });
        function animationFrameUpdate() {
          updateUI();
          requestAnimationFrame(animationFrameUpdate);
        }
        requestAnimationFrame(animationFrameUpdate);
        updateUI();
      } catch (error) {
        console.error('Visualization error:', error);
        document.getElementById('info').innerHTML += '<br>ERROR: Error loading data';
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }
    initializeVisualization();
  </script>
</body>
</html> 