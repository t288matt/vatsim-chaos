<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ATC Conflict Animation - Dynamic Scheduling</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; }
    #cesiumContainer { position: absolute; top: 0; left: 0; }
    #info { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 12px; border-radius: 6px; z-index: 10; font-family: Arial, sans-serif; }
    #info h3 { margin: 0 0 8px 0; color: #00ff88; }
    #info p { margin: 4px 0; font-size: 12px; }
    #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: #00ff88; padding: 20px; border-radius: 8px; z-index: 20; }
    .conflict-alert { background: rgba(255,0,0,0.3); border-left: 3px solid #ff4444; padding: 4px; margin: 2px 0; }
    #commentary-box { 
      position: absolute; 
      bottom: 10px; 
      right: 10px; 
      background: rgba(0,0,0,0.8); 
      color: #00ff88; 
      padding: 12px; 
      border-radius: 6px; 
      z-index: 10; 
      font-family: Arial, sans-serif; 
      max-width: 300px; 
      max-height: 200px; 
      overflow-y: auto;
      border-left: 3px solid #00ff88;
    }
    #commentary-box h4 { margin: 0 0 8px 0; color: #00ff88; font-size: 14px; }
    .departure-log { 
      font-size: 11px; 
      margin: 2px 0; 
      padding: 2px 0; 
      border-bottom: 1px solid rgba(0,255,136,0.3);
    }
    .departure-time { color: #ffff00; font-weight: bold; }
    .flight-id { color: #00ffff; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="loading">Loading ATC Conflict Animation...</div>
  <div id="info">
    <h3>üéØ ATC Conflict Animation</h3>
    <p><strong>Event:</strong> <span id="event-time">14:00-18:00</span></p>
    <p><strong>Flights:</strong> <span id="flight-count">0</span> active</p>
    <p><strong>Conflicts:</strong> <span id="conflict-count">0</span> detected</p>
    <p><strong>Current Time:</strong> <span id="current-time">14:00</span></p>
    <div id="conflict-alerts"></div>
    <button id="toggle-labels">Toggle Flight Labels</button>
  </div>
  <div id="controls" style="position:absolute;top:10px;right:10px;z-index:20;background:rgba(0,0,0,0.7);color:#fff;padding:10px;border-radius:6px;">
    <label>Aircraft Size: <input id="acft-size" type="range" min="64" max="1024" value="512" step="16"> <span id="acft-size-val">512</span></label><br>
    <label>Font Size: <input id="font-size" type="range" min="3" max="32" value="16" step="1"> <span id="font-size-val">16</span> px</label>
  </div>
  <div id="commentary-box">
    <h4>üì¢ Flight Commentary</h4>
    <div id="departure-logs"></div>
  </div>
  <script>
    // Best practice: Set up Cesium viewer and timeline for animation
    window.CESIUM_BASE_URL = 'https://cesium.com/downloads/cesiumjs/releases/1.115/Build/Cesium/';
    const viewer = new Cesium.Viewer('cesiumContainer', {
      timeline: true,
      animation: true,
      shouldAnimate: true,
      baseLayerPicker: false
    });
    viewer.imageryLayers.removeAll();
    viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
      url: 'https://a.tile.openstreetmap.org/'
    }));
    const flightColors = [
      Cesium.Color.YELLOW, Cesium.Color.CYAN, Cesium.Color.LIME, Cesium.Color.ORANGE, 
      Cesium.Color.MAGENTA, Cesium.Color.RED, Cesium.Color.BLUE, Cesium.Color.GREEN,
      Cesium.Color.GOLD, Cesium.Color.AQUA, Cesium.Color.VIOLET, Cesium.Color.ROSE
    ];
    let flights = [];
    let conflicts = [];
    let flightEntities = [];
    let labelVisible = true;
    let selectedFlightId = null;
    let departedFlights = new Set(); // Track which flights have departed
    let lastUpdateTime = 0; // Track last update time to avoid duplicate logs
    document.getElementById('toggle-labels').onclick = () => {
      labelVisible = !labelVisible;
      flightEntities.forEach(e => {
        e.label.show = labelVisible;
      });
    };
    let acftSize = 512;
    let fontSize = 16;
    document.getElementById('acft-size').oninput = function() {
      acftSize = parseInt(this.value);
      document.getElementById('acft-size-val').textContent = acftSize;
      flightEntities.forEach(e => {
        if (e.model) {
          e.model.minimumPixelSize = acftSize;
          e.model.maximumScale = acftSize * 3;
        }
      });
    };
    document.getElementById('font-size').oninput = function() {
      fontSize = parseInt(this.value);
      document.getElementById('font-size-val').textContent = fontSize;
      flightEntities.forEach(e => {
        if (e.label) {
          e.label.font = fontSize + 'px sans-serif';
        }
      });
    };
    function parseTimeToMinutes(timeStr) {
      const [hours, minutes] = timeStr.split(':').map(Number);
      const eventStart = 14 * 60;
      return (hours * 60 + minutes) - eventStart;
    }
    function minutesToTimeString(minutes) {
      const totalMinutes = 14 * 60 + minutes;
      const hours = Math.floor(totalMinutes / 60);
      const mins = totalMinutes % 60;
      return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
    }
    async function loadAnimationData() {
      try {
        const response = await fetch('animation_data.json');
        if (!response.ok) throw new Error('Animation data not found: ' + response.status + ' ' + response.statusText);
        const text = await response.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch (jsonErr) {
          document.getElementById('info').innerHTML += '<br>‚ùå JSON parse error: ' + jsonErr.message;
          return false;
        }
        if (data.flights && Array.isArray(data.flights)) flights = data.flights;
        if (data.conflicts && Array.isArray(data.conflicts)) conflicts = data.conflicts;
        return true;
      } catch (error) {
        document.getElementById('info').innerHTML += '<br>‚ùå Data load error: ' + error.message;
        return false;
      }
    }
    function createScheduledFlights() {
      viewer.entities.removeAll();
      flightEntities = [];
      if (flights.length === 0) return;
      // Calculate global timeline
      let minTime = Infinity, maxTime = -Infinity;
      flights.forEach(flight => {
        const departureMinutes = parseTimeToMinutes(flight.departure_time || '14:00');
        flight.waypoints.forEach(wp => {
          const absoluteTime = departureMinutes + (wp.time_from_departure || 0);
          if (absoluteTime < minTime) minTime = absoluteTime;
          if (absoluteTime > maxTime) maxTime = absoluteTime;
        });
      });
      const start = Cesium.JulianDate.fromDate(new Date(Date.now()));
      const stop = Cesium.JulianDate.addSeconds(start, (maxTime - minTime) * 60, new Cesium.JulianDate());
      // Set currentTime to the start of the first flight (minTime)
      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
      viewer.clock.multiplier = 1;
      viewer.timeline.zoomTo(start, stop);
      viewer.clock.shouldAnimate = true;
      // Create flight entities with animated paths and 3D models
      flights.forEach((flight, idx) => {
        const color = flightColors[idx % flightColors.length];
        const property = new Cesium.SampledPositionProperty();
        const altitudeProperty = new Cesium.SampledProperty(Number);
        let entityStart = Infinity, entityStop = -Infinity;
        const departureMinutes = parseTimeToMinutes(flight.departure_time || '14:00');
        flight.waypoints.forEach(wp => {
          const absoluteTime = departureMinutes + (wp.time_from_departure || 0);
          const t = Cesium.JulianDate.addSeconds(start, absoluteTime * 60, new Cesium.JulianDate());
          property.addSample(t, Cesium.Cartesian3.fromDegrees(wp.lon, wp.lat, wp.altitude));
          altitudeProperty.addSample(t, wp.altitude);
          if (absoluteTime < entityStart) entityStart = absoluteTime;
          if (absoluteTime > entityStop) entityStop = absoluteTime;
        });
        const entityAvailability = new Cesium.TimeIntervalCollection([
          new Cesium.TimeInterval({
            start: Cesium.JulianDate.addSeconds(start, entityStart * 60, new Cesium.JulianDate()),
            stop: Cesium.JulianDate.addSeconds(start, entityStop * 60, new Cesium.JulianDate())
          })
        ]);
        const entity = viewer.entities.add({
          id: flight.flight_id,
          availability: entityAvailability,
          position: property,
          orientation: new Cesium.VelocityOrientationProperty(property),
          model: {
            uri: 'https://cesium.com/downloads/cesiumjs/releases/1.115/Apps/SampleData/models/CesiumAir/Cesium_Air.glb',
            minimumPixelSize: acftSize,
            maximumScale: acftSize * 3,
            color: Cesium.Color.BLACK.withAlpha(0.8),
            colorBlendMode: Cesium.ColorBlendMode.MIX
          },
          path: {
            resolution: 1,
            material: color,
            width: 2,
            leadTime: 0,
            trailTime: 60
          },
          label: {
            text: new Cesium.CallbackProperty(function(time, result) {
              const alt = altitudeProperty.getValue(time);
              return `${flight.flight_id}\nAlt: ${alt !== undefined ? Math.round(alt) : 'N/A'} ft`;
            }, false),
            font: fontSize + 'px sans-serif',
            fillColor: color,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            verticalOrigin: Cesium.VerticalOrigin.CENTER,
            pixelOffset: new Cesium.Cartesian2(60, 80), // Move label lower below the plane
            show: labelVisible
          }
        });
        flightEntities.push(entity);
      });
      // Add conflict points
      // Camera auto-zoom with debug output
      let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
      flights.forEach(flight => {
        flight.waypoints.forEach(wp => {
          if (wp.lat < minLat) minLat = wp.lat;
          if (wp.lat > maxLat) maxLat = wp.lat;
          if (wp.lon < minLon) minLon = wp.lon;
          if (wp.lon > maxLon) maxLon = wp.lon;
        });
      });
      if (minLat < maxLat && minLon < maxLon && (maxLat - minLat > 0.01) && (maxLon - minLon > 0.01)) {
        viewer.zoomTo(viewer.entities);
      } else {
        const ausRect = Cesium.Rectangle.fromDegrees(110, -45, 155, -10);
        viewer.camera.flyTo({ destination: ausRect, duration: 1.5 });
      }
    }
    function updateUI() {
      document.getElementById('flight-count').textContent = flights.length;
      document.getElementById('conflict-count').textContent = conflicts.length;
      const currentTime = viewer.clock.currentTime;
      const seconds = Cesium.JulianDate.secondsDifference(currentTime, viewer.clock.startTime);
      const minutes = Math.floor(seconds / 60);
      const timeStr = minutesToTimeString(minutes);
      document.getElementById('current-time').textContent = timeStr;
      
      // Check for new departures
      checkForDepartures(minutes, timeStr);
      
      const activeConflicts = conflicts.filter(conflict => {
        const conflictTime = conflict.time1 || 0;
        return Math.abs(minutes - conflictTime) < 2;
      });
      const alertsDiv = document.getElementById('conflict-alerts');
      alertsDiv.innerHTML = '';
      activeConflicts.forEach(conflict => {
        const alertDiv = document.createElement('div');
        alertDiv.className = 'conflict-alert';
        alertDiv.innerHTML = `‚ö†Ô∏è ${conflict.flight1} vs ${conflict.flight2} at ${conflict.location}`;
        alertsDiv.appendChild(alertDiv);
      });
    }
    
    function checkForDepartures(currentMinutes, timeStr) {
      flights.forEach(flight => {
        const departureMinutes = parseTimeToMinutes(flight.departure_time || '14:00');
        if (currentMinutes >= departureMinutes && !departedFlights.has(flight.flight_id)) {
          departedFlights.add(flight.flight_id);
          logDeparture(flight.flight_id, timeStr, flight.departure_time);
        }
      });
    }
    
    function logDeparture(flightId, currentTime, scheduledTime) {
      const logsDiv = document.getElementById('departure-logs');
      const logEntry = document.createElement('div');
      logEntry.className = 'departure-log';
      logEntry.innerHTML = `<span class="departure-time">${currentTime}</span> - <span class="flight-id">${flightId}</span> departed (scheduled: ${scheduledTime})`;
      logsDiv.appendChild(logEntry);
      
      // Keep only last 10 entries to prevent overflow
      while (logsDiv.children.length > 10) {
        logsDiv.removeChild(logsDiv.firstChild);
      }
      
      // Auto-scroll to bottom
      logsDiv.scrollTop = logsDiv.scrollHeight;
    }
    // Highlight selected flight
    viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
      const pickedObject = viewer.scene.pick(movement.position);
      if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.id) {
        const flightId = pickedObject.id.id;
        selectedFlightId = flightId;
        flightEntities.forEach(e => {
          if (e.id === flightId) {
            e.path.material = Cesium.Color.WHITE;
            e.path.width = 6;
          } else {
            e.path.material = flightColors.find(c => c.equals(e.path.material)) || Cesium.Color.YELLOW;
            e.path.width = 2;
          }
        });
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    async function initializeVisualization() {
      document.getElementById('loading').style.display = 'block';
      try {
        const animationLoaded = await loadAnimationData();
        if (animationLoaded) {
          createScheduledFlights();
        } else {
          flights = [
            {
              flight_id: 'Demo Flight 1',
              departure_time: '14:00',
              waypoints: [
                { lon: 151.177, lat: -33.946, altitude: 0, time_from_departure: 0 },
                { lon: 153.117, lat: -27.384, altitude: 10000, time_from_departure: 10 },
                { lon: 144.843, lat: -37.673, altitude: 0, time_from_departure: 20 }
              ]
            }
          ];
          createScheduledFlights();
        }
        // Remove viewer.clock.onTick.addEventListener(updateUI);
        // Instead, use requestAnimationFrame for UI updates
        function animationFrameUpdate() {
          updateUI();
          requestAnimationFrame(animationFrameUpdate);
        }
        requestAnimationFrame(animationFrameUpdate);
        updateUI();
      } catch (error) {
        document.getElementById('info').innerHTML += '<br>‚ùå Error loading data';
      } finally {
        document.getElementById('loading').style.display = 'none';
      }
    }
    initializeVisualization();
  </script>
</body>
</html> 